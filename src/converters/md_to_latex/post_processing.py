"""Post-processing module for cleaning up LaTeX output after pandoc conversion."""

import logging

# import re  # Banned - using string methods instead
from pathlib import Path

logger = logging.getLogger(__name__)


class LatexPostProcessor:
    """Clean up common issues in LaTeX files generated by pandoc."""

    def __init__(self):
        """Initialize the post-processor."""
        self.fixes_applied = []

    def process_file(self, latex_file: Path) -> None:
        """Process a LaTeX file and apply all cleaning routines.

        Args:
            latex_file: Path to the LaTeX file to process
        """
        logger.info(f"Post-processing LaTeX file: {latex_file}")

        # Read the file
        content = latex_file.read_text(encoding="utf-8")
        original_content = content

        # Apply all fixes
        content = self._fix_passthrough_commands(content)
        content = self._fix_table_alignment_issues(content)
        content = self._fix_strut_commands(content)
        content = self._fix_empty_captions(content)
        content = self._fix_nested_emphasis(content)
        content = self._fix_href_in_tables(content)
        content = self._fix_href_citations(content)
        content = self._consolidate_citations(content)
        content = self._convert_horizontal_rules_to_boxes(content)
        content = self._clean_excessive_line_breaks(content)

        # Write back if changes were made
        if content != original_content:
            latex_file.write_text(content, encoding="utf-8")
            logger.info(
                f"Applied {len(self.fixes_applied)} fixes to {latex_file}"
            )
            for fix in self.fixes_applied:
                logger.debug(f"  - {fix}")
        else:
            logger.info("No fixes needed")

    def _fix_passthrough_commands(self, content: str) -> str:
        r"""Fix pandoc's passthrough commands that aren't standard LaTeX.

        Converts \passthrough{\lstinline!...!} to \texttt{...}
        """
        # Find and replace passthrough commands without regex
        result = []
        i = 0

        while i < len(content):
            if content[i : i + 12] == "\\passthrough":
                # Found passthrough, check if it's the pattern we want
                if (
                    i + 23 < len(content)
                    and content[i + 12 : i + 13] == "{"
                    and content[i + 13 : i + 23] == "\\lstinline"
                ):
                    # Look for delimiter after \lstinline
                    j = i + 23
                    # Handle both \! and ! patterns
                    if (
                        j + 1 < len(content)
                        and content[j] == "\\"
                        and content[j + 1] == "!"
                    ):
                        # \! pattern - start after \!
                        content_start = j + 2
                        # Find the closing \!
                        k = content_start
                        while k + 1 < len(content):
                            if content[k] == "\\" and content[k + 1] == "!":
                                break
                            k += 1

                        if (
                            k + 1 < len(content)
                            and content[k] == "\\"
                            and content[k + 1] == "!"
                        ):
                            # Extract the content between \! ... \!
                            inner_content = content[content_start:k]

                            # Skip the closing \! and check for }
                            end_pos = k + 2
                            if (
                                end_pos < len(content)
                                and content[end_pos] == "}"
                            ):
                                result.append(f"\\texttt{{{inner_content}}}")
                                self.fixes_applied.append(
                                    "Fixed passthrough command"
                                )
                                i = end_pos + 1
                                continue

                    elif j < len(content) and content[j] == "!":
                        # Regular ! pattern - start after !
                        content_start = j + 1
                        # Find the closing !
                        k = content_start
                        while k < len(content):
                            if content[k] == "!":
                                break
                            k += 1

                        if k < len(content) and content[k] == "!":
                            # Extract the content between ! ... !
                            inner_content = content[content_start:k]

                            # Skip the closing ! and check for }
                            end_pos = k + 1
                            if (
                                end_pos < len(content)
                                and content[end_pos] == "}"
                            ):
                                result.append(f"\\texttt{{{inner_content}}}")
                                self.fixes_applied.append(
                                    "Fixed passthrough command"
                                )
                                i = end_pos + 1
                                continue

            result.append(content[i])
            i += 1

        return "".join(result)

    def _fix_table_alignment_issues(self, content: str) -> str:
        """Fix table alignment issues where row has more columns than defined.

        This is a common issue when markdown tables have inconsistent columns.
        """
        # Process tables by finding environments
        lines = content.split("\n")
        result_lines = []
        i = 0

        while i < len(lines):
            line = lines[i]

            # Check for table environment start
            if "\\begin{tabular}" in line or "\\begin{longtable}" in line:
                # Extract column spec
                col_spec = ""
                if "\\begin{tabular}{" in line:
                    start = line.find("\\begin{tabular}{") + 16
                elif "\\begin{longtable}{" in line:
                    start = line.find("\\begin{longtable}{") + 18
                else:
                    result_lines.append(line)
                    i += 1
                    continue

                # Find closing brace
                brace_count = 1
                j = start
                while j < len(line) and brace_count > 0:
                    if line[j] == "{":
                        brace_count += 1
                    elif line[j] == "}":
                        brace_count -= 1
                    j += 1

                if brace_count == 0:
                    col_spec = line[start : j - 1]

                # Count expected columns
                expected_cols = 0
                # Clean spec by removing @{...} patterns
                clean_spec = col_spec
                while "@{" in clean_spec:
                    at_pos = clean_spec.find("@{")
                    if at_pos != -1:
                        # Find matching }
                        brace_count = 1
                        k = at_pos + 2
                        while k < len(clean_spec) and brace_count > 0:
                            if clean_spec[k] == "{":
                                brace_count += 1
                            elif clean_spec[k] == "}":
                                brace_count -= 1
                            k += 1
                        clean_spec = clean_spec[:at_pos] + clean_spec[k:]

                # Count column indicators
                for char in clean_spec:
                    if char in "lcr":
                        expected_cols += 1
                    elif char == "p":
                        expected_cols += 1

                if expected_cols == 0:
                    result_lines.append(line)
                    i += 1
                    continue

                # Process table content
                result_lines.append(line)
                i += 1

                # Process rows until end of table
                while i < len(lines):
                    line = lines[i]

                    if "\\end{tabular}" in line or "\\end{longtable}" in line:
                        result_lines.append(line)
                        i += 1
                        break

                    # Check if this is a data row (contains &)
                    if "&" in line and not line.strip().startswith("%"):
                        # Count columns (unescaped &)
                        actual_cols = 1
                        j = 0
                        while j < len(line):
                            if line[j] == "&" and (
                                j == 0 or line[j - 1] != "\\"
                            ):
                                actual_cols += 1
                            j += 1

                        if actual_cols > expected_cols:
                            # Fix by merging extra columns
                            fixed_line = self._fix_table_row(
                                line, expected_cols, actual_cols
                            )
                            result_lines.append(fixed_line)
                            self.fixes_applied.append(
                                f"Fixed table row with {actual_cols} columns (expected {expected_cols})"
                            )
                        else:
                            result_lines.append(line)
                    else:
                        result_lines.append(line)

                    i += 1
            else:
                result_lines.append(line)
                i += 1

        return "\n".join(result_lines)

    def _fix_table_row(
        self, row: str, expected_cols: int, actual_cols: int
    ) -> str:
        """Fix a table row that has too many columns."""
        # Split by unescaped &
        cells = []
        current_cell = []
        i = 0

        while i < len(row):
            if row[i] == "&" and (i == 0 or row[i - 1] != "\\"):
                cells.append("".join(current_cell))
                current_cell = []
            else:
                current_cell.append(row[i])
            i += 1

        if current_cell:
            cells.append("".join(current_cell))

        # If we have too many cells, merge the excess ones
        if len(cells) > expected_cols:
            # Take first (expected_cols - 1) cells as is
            fixed_cells = cells[: expected_cols - 1]

            # Merge all remaining cells into the last column
            last_cell_content = []
            for i in range(expected_cols - 1, len(cells)):
                last_cell_content.append(cells[i].strip())

            # Join with spaces instead of &
            merged_last_cell = " ".join(last_cell_content)
            fixed_cells.append(merged_last_cell)

            return " & ".join(fixed_cells)

        return row

    def _fix_strut_commands(self, content: str) -> str:
        r"""Remove or fix problematic \strut commands in tables."""
        original_content = content

        # Remove \strut at the end of table cells and lines
        content = content.replace("\\strut \\\\", "\\\\")
        content = content.replace("\\strut &", " &")
        content = content.replace("\\strut\n", "\n")
        content = content.replace("\\strut\\\\", "\\\\")

        if content != original_content:
            self.fixes_applied.append("Cleaned up \\strut commands")

        return content

    def _fix_empty_captions(self, content: str) -> str:
        """Fix empty figure/table captions that might cause LaTeX errors."""
        # Fix empty captions
        content = content.replace("\\caption{}", "\\caption{~}")
        content = content.replace("\\caption{ }", "\\caption{~}")
        content = content.replace("\\caption{\n}", "\\caption{~}")

        # Fix captions with only label - more complex without regex
        lines = content.split("\n")
        result_lines = []

        for i, line in enumerate(lines):
            if "\\caption{" in line:
                caption_start = line.find("\\caption{")
                if caption_start != -1:
                    # Check if it only contains a label
                    caption_content = line[caption_start + 9 :]
                    if caption_content.strip().startswith("\\label{"):
                        # Find the end of caption
                        brace_count = 1
                        j = 0
                        while j < len(caption_content) and brace_count > 0:
                            if caption_content[j] == "{":
                                brace_count += 1
                            elif caption_content[j] == "}":
                                brace_count -= 1
                            j += 1

                        if brace_count == 0:
                            # Extract label
                            label_part = caption_content[:j]
                            remainder = caption_content[j:]
                            # Reconstruct with ~
                            new_line = (
                                line[:caption_start]
                                + "\\caption{~"
                                + label_part
                                + remainder
                            )
                            result_lines.append(new_line)
                            self.fixes_applied.append(
                                "Fixed empty caption with label"
                            )
                            continue

            result_lines.append(line)

        return "\n".join(result_lines)

    def _fix_nested_emphasis(self, content: str) -> str:
        """Fix nested emphasis commands that might cause issues."""
        # Fix \emph{\emph{...}} -> \emph{...}
        while "\\emph{\\emph{" in content:
            pos = content.find("\\emph{\\emph{")
            if pos != -1:
                # Find the matching braces
                start = pos + 12  # After \emph{\emph{
                brace_count = 1
                i = start

                while i < len(content) and brace_count > 0:
                    if content[i] == "{":
                        brace_count += 1
                    elif content[i] == "}":
                        brace_count -= 1
                    i += 1

                if brace_count == 0:
                    # Found the inner content
                    inner_content = content[start : i - 1]
                    # Skip the next }
                    if i < len(content) and content[i] == "}":
                        i += 1

                    # Replace with single \emph
                    content = (
                        content[:pos]
                        + f"\\emph{{{inner_content}}}"
                        + content[i:]
                    )
                    self.fixes_applied.append("Fixed nested emphasis")
                else:
                    break

        return content

    def _fix_href_in_tables(self, content: str) -> str:
        """Fix long hrefs in tables that might cause overfull hboxes."""
        # Find table environments and process hrefs within them
        lines = content.split("\n")
        result_lines = []
        in_table = False

        for line in lines:
            if "\\begin{tabular}" in line or "\\begin{longtable}" in line:
                in_table = True
            elif "\\end{tabular}" in line or "\\end{longtable}" in line:
                in_table = False

            if in_table and "\\href{" in line:
                # Process hrefs in this line
                result = []
                i = 0

                while i < len(line):
                    if line[i : i + 6] == "\\href{":
                        # Found href, extract URL and text
                        url_start = i + 6
                        brace_count = 1
                        j = url_start

                        # Find end of URL
                        while j < len(line) and brace_count > 0:
                            if line[j] == "{":
                                brace_count += 1
                            elif line[j] == "}":
                                brace_count -= 1
                            j += 1

                        if (
                            brace_count == 0
                            and j < len(line)
                            and line[j] == "{"
                        ):
                            # Found URL, now get text
                            url = line[url_start : j - 1]
                            text_start = j + 1
                            brace_count = 1
                            k = text_start

                            while k < len(line) and brace_count > 0:
                                if line[k] == "{":
                                    brace_count += 1
                                elif line[k] == "}":
                                    brace_count -= 1
                                k += 1

                            if brace_count == 0:
                                text = line[text_start : k - 1]

                                # If URL is long and same as text, shorten display
                                if len(url) > 50 and url == text:
                                    shortened = url[:30] + "..." + url[-15:]
                                    result.append(
                                        f"\\href{{{url}}}{{{shortened}}}"
                                    )
                                    self.fixes_applied.append(
                                        "Shortened long URL in table"
                                    )
                                else:
                                    result.append(f"\\href{{{url}}}{{{text}}}")

                                i = k
                                continue

                    result.append(line[i])
                    i += 1

                result_lines.append("".join(result))
            else:
                result_lines.append(line)

        return "\n".join(result_lines)

    def _fix_href_citations(self, content: str) -> str:
        """Convert academic hrefs that should be citations to citep commands."""
        # This is complex without regex - need to find academic URLs
        academic_domains = [
            "doi.org",
            "dx.doi.org",
            "arxiv.org",
            "sciencedirect.com",
            "springer.com",
            "wiley.com",
            "nature.com",
            "science.org",
            "plos.org",
            "ieee.org",
            "acm.org",
            "jstor.org",
            "pubmed",
            "ncbi.nlm.nih.gov",
            "researchgate.net",
            "academia.edu",
            "scholar.google",
            "ssrn.com",
            "elsevier.com",
            "tandfonline.com",
            "sagepub.com",
            "oup.com",
            "cambridge.org",
        ]

        result = []
        i = 0

        while i < len(content):
            if content[i : i + 6] == "\\href{":
                # Check if URL is academic
                url_start = i + 6
                brace_count = 1
                j = url_start

                # Find end of URL
                while j < len(content) and brace_count > 0:
                    if content[j] == "{":
                        brace_count += 1
                    elif content[j] == "}":
                        brace_count -= 1
                    j += 1

                if brace_count == 0:
                    url = content[url_start : j - 1]

                    # Check if academic URL
                    is_academic = any(
                        domain in url for domain in academic_domains
                    )

                    if is_academic and j < len(content) and content[j] == "{":
                        # Get the link text
                        text_start = j + 1
                        brace_count = 1
                        k = text_start

                        while k < len(content) and brace_count > 0:
                            if content[k] == "{":
                                brace_count += 1
                            elif content[k] == "}":
                                brace_count -= 1
                            k += 1

                        if brace_count == 0:
                            text = content[text_start : k - 1]

                            # Check if text looks like "Author Year"
                            words = text.split()
                            if len(words) >= 2:
                                # Check if last word is a year
                                last_word = words[-1]
                                if len(last_word) == 4 and last_word.isdigit():
                                    year = last_word
                                    if year.startswith(("19", "20")):
                                        # Extract author
                                        author_parts = words[:-1]
                                        if (
                                            author_parts
                                            and author_parts[0][0].isupper()
                                        ):
                                            # Create citation key
                                            author_key = (
                                                author_parts[0]
                                                .lower()
                                                .replace("et", "")
                                                .replace("al.", "etal")
                                            )
                                            citation_key = f"{author_key}{year}"

                                            result.append(
                                                f"\\citep{{{citation_key}}}"
                                            )
                                            self.fixes_applied.append(
                                                f"Converted href citation to citep: {text}"
                                            )
                                            i = k
                                            continue

            result.append(content[i])
            i += 1

        return "".join(result)

    def _clean_excessive_line_breaks(self, content: str) -> str:
        """Clean up excessive line breaks that might cause formatting issues."""
        # Replace more than 3 consecutive empty lines with 2
        lines = content.split("\n")
        result_lines = []
        empty_count = 0

        for line in lines:
            if not line.strip():
                empty_count += 1
                if empty_count <= 3:
                    result_lines.append(line)
            else:
                empty_count = 0
                result_lines.append(line)

        # Remove \\ at end of non-table lines
        final_lines = []
        in_table = False

        for line in result_lines:
            if "\\begin{tabular}" in line or "\\begin{longtable}" in line:
                in_table = True
            elif "\\end{tabular}" in line or "\\end{longtable}" in line:
                in_table = False

            if not in_table and line.endswith("\\\\"):
                line = line[:-2]

            final_lines.append(line)

        return "\n".join(final_lines)

    def _itemize_if_needed(self, content: str) -> str:
        """Convert content to itemized list if it appears to be list-like.

        Detects patterns like:
        - Multiple lines with colons (e.g., "Content: something")
        - Lines that look like list items
        - Preserves already formatted lists
        """
        # If content already has list formatting, return as-is
        if any(
            marker in content
            for marker in ["\\begin{itemize}", "\\begin{enumerate}", "\\item"]
        ):
            return content

        lines = content.split("\n")
        if len(lines) < 2:
            return content

        # Check if lines look like list items (contain colons or are short statements)
        list_like_lines = []
        non_list_lines = []

        for line in lines:
            line = line.strip()
            if not line:
                continue

            # Check if line looks like a list item
            # Pattern 1: "Label: content" format
            # Pattern 2: Short statement (less than 100 chars) that's not obviously a paragraph
            if ":" in line and line.index(":") < 30:  # Colon near the beginning
                list_like_lines.append(line)
            elif len(line) < 100 and not line.endswith("."):
                # Short line that doesn't end with period might be a list item
                list_like_lines.append(line)
            else:
                non_list_lines.append(line)

        # If most lines look like list items, convert to itemized list
        if len(list_like_lines) >= 2 and len(list_like_lines) >= len(
            non_list_lines
        ):
            itemized = "\\begin{itemize}\n"
            for line in lines:
                if line.strip():
                    itemized += f"\\item {line.strip()}\n"
            itemized += "\\end{itemize}"

            # Add any non-list content after the list
            if non_list_lines:
                itemized += "\n" + " ".join(non_list_lines)

            return itemized

        return content

    def _convert_horizontal_rules_to_boxes(self, content: str) -> str:
        """Convert marked concept boxes to tcolorbox environments."""
        # Find concept box markers
        box_count = 0
        result = []
        i = 0

        while i < len(content):
            # Look for CONCEPTBOXSTART pattern
            if content[i:].startswith("CONCEPTBOXSTART\\{"):
                # Find title
                title_start = i + 17  # After CONCEPTBOXSTART\{
                title_end = content.find("\\}CONCEPTBOXSTART", title_start)

                if title_end != -1:
                    title = content[title_start:title_end]

                    # Find content end
                    content_start = title_end + 17  # After \}CONCEPTBOXSTART
                    content_end = content.find("CONCEPTBOXEND", content_start)

                    if content_end != -1:
                        box_content = content[content_start:content_end].strip()

                        # Clean up content
                        box_content = box_content.replace(
                            "\\textbackslash{}", "\\"
                        )
                        box_content = box_content.replace("\\{", "{")
                        box_content = box_content.replace("\\}", "}")

                        # Remove lines that are just the title repeated
                        lines = box_content.split("\n")
                        cleaned_lines = []
                        for line in lines:
                            # Skip lines that are just the title or "Technical Concept Box: title"
                            line_strip = line.strip()
                            if line_strip and not (
                                line_strip == f"\\textbf{{{title}}}"
                                or line_strip
                                == f"\\emph{{Technical Concept Box: {title}}}"
                                or line_strip
                                == f"Technical Concept Box: {title}"
                                or line_strip
                                == f"*Technical Concept Box: {title}*"
                                or line_strip
                                == f"**Technical Concept Box: {title}**"
                            ):
                                cleaned_lines.append(line)

                        box_content = "\n".join(cleaned_lines).strip()

                        # Check if content should be itemized
                        box_content = self._itemize_if_needed(box_content)

                        box_count += 1

                        # Create the tcolorbox
                        tcolorbox = f"""\\begin{{tcolorbox}}[
    colback={{rgb,255:red,218;green,224;blue,232}},
    colframe={{rgb,255:red,180;green,190;blue,200}},
    title={{\\textbf{{{title}}}}},
    fonttitle=\\bfseries,
    boxrule=1pt,
    arc=4pt,
    outer arc=4pt,
    top=10pt,
    bottom=10pt,
    left=10pt,
    right=10pt
]
{box_content}
\\end{{tcolorbox}}"""

                        result.append(tcolorbox)
                        i = content_end + 13  # After CONCEPTBOXEND
                        continue

            result.append(content[i])
            i += 1

        content = "".join(result)

        if box_count > 0:
            self.fixes_applied.append(
                f"Converted {box_count} marked concept boxes to tcolorbox environments"
            )

            # Ensure tcolorbox package is loaded
            if "\\usepackage{tcolorbox}" not in content:
                # Add tcolorbox before hyperref
                if "\\usepackage{hyperref}" in content:
                    content = content.replace(
                        "\\usepackage{hyperref}",
                        "\\usepackage{tcolorbox}\n\\usepackage[most]{tcolorbox}\n\\tcbuselibrary{skins,breakable}\n\n\\usepackage{hyperref}",
                    )
                else:
                    # Fallback: add after documentclass
                    docclass_pos = content.find("\\documentclass")
                    if docclass_pos != -1:
                        # Find end of line
                        newline_pos = content.find("\n", docclass_pos)
                        if newline_pos != -1:
                            content = (
                                content[: newline_pos + 1]
                                + "\\usepackage{tcolorbox}\n\\usepackage[most]{tcolorbox}\n\\tcbuselibrary{skins,breakable}\n"
                                + content[newline_pos + 1 :]
                            )

        return content

    def _consolidate_citations(self, content: str) -> str:
        """Consolidate consecutive citep commands into single commands.

        Converts patterns like:
        - (\\citep{key1}, \\citep{key2}, \\citep{key3}) → \\citep{key1, key2, key3}
        - \\citep{key1}; \\citep{key2} → \\citep{key1, key2}

        Also sorts citation keys chronologically by extracting year from the key.
        """
        lines = content.split("\n")
        result = []

        for line in lines:
            # Skip if no citep commands
            if "\\citep{" not in line:
                result.append(line)
                continue

            # Process line character by character to find citation groups
            processed_line = ""
            i = 0
            while i < len(line):
                # Check if we're at the start of a citation pattern
                if i + 7 <= len(line) and line[i : i + 7] == "\\citep{":
                    # Find all consecutive citations
                    citations = []
                    start_pos = i

                    while i < len(line):
                        # Found a \citep{
                        if i + 7 <= len(line) and line[i : i + 7] == "\\citep{":
                            # Extract the citation key
                            brace_start = i + 7
                            brace_count = 1
                            j = brace_start

                            while j < len(line) and brace_count > 0:
                                if line[j] == "{":
                                    brace_count += 1
                                elif line[j] == "}":
                                    brace_count -= 1
                                j += 1

                            if brace_count == 0:
                                cite_key = line[brace_start : j - 1]
                                citations.append(cite_key)
                                i = j

                                # Check what comes after the citation
                                # Skip whitespace
                                while i < len(line) and line[i] in " \t":
                                    i += 1

                                # Check for separators (;, comma, closing paren)
                                if i < len(line) and line[i] in ";,)":
                                    i += 1  # Skip separator
                                    # Skip more whitespace
                                    while i < len(line) and line[i] in " \t":
                                        i += 1

                                    # Check if there's a paren
                                    if i < len(line) and line[i] == "(":
                                        i += 1
                                        while (
                                            i < len(line) and line[i] in " \t"
                                        ):
                                            i += 1
                                    # Continue looking for more citations
                                    continue
                                else:
                                    # No separator, end of citation group
                                    break
                            else:
                                # Malformed citation, skip
                                break
                        else:
                            # Not a citation, end of group
                            break

                    # If we found multiple citations, consolidate them
                    if len(citations) > 1:
                        # Sort by year (extract from citation key)
                        def extract_year(key):
                            # Try to find 4-digit year in the key
                            for i in range(len(key) - 3):
                                if key[i : i + 4].isdigit():
                                    return int(key[i : i + 4])
                            return 9999  # Unknown year goes last

                        citations.sort(key=extract_year)

                        # Add consolidated citation
                        processed_line += f"\\citep{{{', '.join(citations)}}}"
                        self.fixes_applied.append(
                            f"Consolidated {len(citations)} citations: "
                            f"{citations[0]}...{citations[-1]}"
                        )
                    else:
                        # Single citation, keep as-is
                        processed_line += line[start_pos:i]
                else:
                    # Not a citation command, copy character
                    processed_line += line[i]
                    i += 1

            result.append(processed_line)

        return "\n".join(result)


def post_process_latex_file(latex_file: Path) -> None:
    """Convenience function to post-process a LaTeX file.

    Args:
        latex_file: Path to the LaTeX file to process
    """
    processor = LatexPostProcessor()
    processor.process_file(latex_file)
